<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>apartmento / L'Espace IntÃ©rieur</title>
  <meta name="description" content="Un espace de contemplation digitale â€” oÃ¹ la lumiÃ¨re habite l'architecture de la pensÃ©e." />
  <style>
    html, body { margin:0; padding:0; height:100%; background:linear-gradient(to bottom, #0b1020 0%, #04060c 100%); overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #c { width:100vw; height:100vh; display:block; }
    .hud {
      position:fixed; inset:0; pointer-events:none;
      display:flex; flex-direction:column; justify-content:space-between;
      padding:20px 20px calc(20px + env(safe-area-inset-bottom)) calc(20px + env(safe-area-inset-left));
      color:rgba(255,255,255,0.88);
    }
    .top {
      display:flex; justify-content:space-between; gap:12px; align-items:flex-start;
      pointer-events:none;
    }
    .pillbar { display:flex; gap:8px; pointer-events:auto; flex-wrap: wrap; }
    .pill {
      pointer-events:auto;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(12,14,22,0.55);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius:999px;
      padding:9px 12px;
      font-size:12px;
      letter-spacing:0.25px;
      line-height:1;
      cursor:pointer;
      user-select:none;
      display:flex; align-items:center; gap:8px;
      transition: all 180ms ease;
    }
    .pill:hover { border-color: rgba(200,220,255,0.35); background:rgba(20,24,36,0.65); }
    .pill.active { border-color: rgba(180,200,255,0.55); background:rgba(25,32,52,0.68); }
    .pill kbd {
      font-size:10px; opacity:0.65; border:1px solid rgba(255,255,255,0.15);
      border-radius:6px; padding:2px 5px; background:rgba(255,255,255,0.05);
    }
    .brand {
      pointer-events:none;
      display:flex; flex-direction:column; gap:8px;
      max-width:min(480px, 88vw);
    }
    .title { 
      font-size:16px; 
      letter-spacing:0.4px; 
      opacity:0.94; 
      font-weight:300;
    }
    .title span { opacity:0.5; font-weight:200; }
    .subtitle { font-size:12px; opacity:0.58; line-height:1.45; font-weight:300; }
    .bottom {
      display:flex; justify-content:space-between; align-items:flex-end; gap:16px;
    }
    .note {
      pointer-events:auto;
      max-width:min(560px, 90vw);
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(12,14,22,0.48);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border-radius:20px;
      padding:14px 16px;
      font-size:12px;
      line-height:1.5;
      opacity:0.9;
    }
    .note-text {
      font-weight:300;
      letter-spacing:0.1px;
    }
    .hint {
      opacity:0.5;
      font-size:11px;
      margin-top:10px;
      font-weight:300;
    }
    .toast {
      position:fixed; left:50%; bottom:28px; transform:translateX(-50%);
      padding:9px 14px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(12,14,22,0.78);
      color:rgba(255,255,255,0.9);
      font-size:12px;
      opacity:0; pointer-events:none;
      transition: opacity 200ms ease;
    }
    .toast.show { opacity:1; }
    @media (max-width: 560px){
      .brand { max-width: 180px; }
      .subtitle { display:none; }
      .note { border-radius:16px; padding:12px 14px; }
      .pill { padding: 8px 10px; font-size: 11px; }
      .pill kbd { display: none; }
    }
  
    body.zen .hud { opacity: 0; transition: opacity 320ms ease; }
    body.zen .hud:hover { opacity: 1; }
    body.cursor-hide { cursor: none; }

    /* Signature */
    .signature {
      position:fixed;
      bottom:20px;
      right:20px;
      font-size:10px;
      opacity:0.35;
      letter-spacing:0.5px;
      pointer-events:none;
    }

    /* Language toggle */
    .lang-toggle {
      display:flex; gap:6px; margin-bottom:10px; pointer-events:auto;
    }
    .lang-toggle button {
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.05);
      color:rgba(255,255,255,0.75);
      padding:5px 10px;
      border-radius:999px;
      font-size:11px;
      cursor:pointer;
      transition: all 150ms ease;
    }
    .lang-toggle button:hover { background:rgba(255,255,255,0.1); }
    .lang-toggle button.active { 
      border-color: rgba(180,200,255,0.5); 
      background:rgba(120,160,255,0.12); 
      color:rgba(255,255,255,0.95);
    }
    [data-lang] { display:none; }
    [data-lang].visible { display:inline; }

    /* EntrÃ©e / Accueil */
    .pillbar { opacity: 0; transition: opacity 1.2s ease; }
    .pillbar.revealed { opacity: 1; }
    .note { opacity: 0; transition: opacity 1.5s ease 0.3s; }
    .note.revealed { opacity: 0.9; }
    .brand { opacity: 0; transition: opacity 2s ease; }
    .brand.revealed { opacity: 1; }

    /* Nappe Bleue Source â€” Le lieu d'oÃ¹ tout apparaÃ®t */
    .blue-source {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      transition: opacity 3s ease;
      background: radial-gradient(
        ellipse 120% 100% at 50% 60%,
        rgba(47, 107, 255, 0.14) 0%,
        rgba(47, 107, 255, 0.08) 35%,
        rgba(30, 70, 180, 0.04) 60%,
        transparent 85%
      );
    }
    .blue-source.revealed {
      opacity: 1;
    }
    .blue-source::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(
        circle at 50% 40%,
        rgba(53, 108, 255, 0.06) 0%,
        transparent 50%
      );
      animation: breatheBlue 12s ease-in-out infinite;
    }
    @keyframes breatheBlue {
      0%, 100% { opacity: 0.7; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.05); }
    }

    /* Canvas â€” apparition diffÃ©rÃ©e */
    #c {
      opacity: 0;
      transition: opacity 2.5s ease;
    }
    #c.revealed {
      opacity: 1;
    }

    /* SÃ©quence d'entrÃ©e â€” halo central + texte-lumiÃ¨re */
    .entry-halo {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 28vmin;
      height: 28vmin;
      transform: translate(-50%, -50%) scale(0.7);
      border-radius: 999px;
      pointer-events: none;
      opacity: 0;
      z-index: 2;
      background: radial-gradient(
        circle at 50% 50%,
        rgba(190, 210, 255, 0.18) 0%,
        rgba(150, 180, 255, 0.10) 35%,
        rgba(40, 70, 140, 0.02) 70%,
        transparent 100%
      );
      filter: blur(2px);
    }

    .entry-text {
      position: fixed;
      left: 50%;
      top: 45%;
      transform: translateX(-50%);
      pointer-events: none;
      font-size: 14px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-weight: 300;
      text-align: center;
      color: rgba(255,255,255,0.9);
      opacity: 0;
      z-index: 3;
      text-shadow: 0 0 4px rgba(180, 200, 255, 0.55);
    }

    .entry-text span {
      display: none;
    }
    .entry-text span.visible {
      display: inline;
    }

  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <!-- Nappe Bleue Source â€” Le lieu d'oÃ¹ tout apparaÃ®t -->
  <div class="blue-source" id="blueSource"></div>
  
  <canvas id="c"></canvas>

  <!-- SÃ©quence d'entrÃ©e perceptive -->
  <div id="entryHalo" class="entry-halo"></div>
  <div id="entryText" class="entry-text">
    <span data-lang="fr" class="visible">ENTREZ.<br/>RESTEZ.</span>
    <span data-lang="ko">ë“¤ì–´ì˜¤ì„¸ìš”.<br/>ë¨¸ë¬´ë¥´ì„¸ìš”.</span>
  </div>

  <div class="hud" aria-hidden="true">
    <div class="top">
      <div class="brand">
        <div class="title">apartmento <span data-lang="fr">/ L'Espace IntÃ©rieur</span><span data-lang="ko" class="visible">/ ë‚´ë©´ì˜ ê³µê°„</span></div>
        <div class="subtitle">
          <span data-lang="fr" class="visible">Un espace de contemplation digitale â€” oÃ¹ la lumiÃ¨re habite l'architecture de la pensÃ©e.</span>
          <span data-lang="ko">ë¹›ì´ ì‚¬ìœ ì˜ ê±´ì¶•ì„ ê±°ë‹ˆëŠ” ë””ì§€í„¸ ëª…ìƒ ê³µê°„.</span>
        </div>
      </div>

      <div class="pillbar">
        <div id="btnSignature" class="pill" title="EntrÃ©e â€” Signature"><span>â—</span><kbd>0</kbd></div>
        <div id="btnA" class="pill" title="Aube â€” First light"><span>Aube</span><kbd>1</kbd></div>
        <div id="btnB" class="pill" title="Jour â€” Full presence"><span>Jour</span><kbd>2</kbd></div>
        <div id="btnC" class="pill" title="CrÃ©puscule â€” Golden hour"><span>CrÃ©puscule</span><kbd>3</kbd></div>
        <div id="btnD" class="pill" title="Nuit â€” Deep rest"><span>Nuit</span><kbd>4</kbd></div>
        <div id="btnSound" class="pill" title="Son"><span id="soundIcon">ğŸ”‡</span><kbd>S</kbd></div>
        <div id="btnPosture" class="pill" title="Mur / Sol"><span id="postureIcon">â–</span><kbd>V</kbd></div>
        <div id="btnFullscreen" class="pill" title="Plein Ã©cran"><span>â›¶</span><kbd>F</kbd></div>
        <div id="btnZen" class="pill" title="Mode Zen"><span>Zen</span><kbd>Z</kbd></div>
        <div id="btnCapture" class="pill" title="Capturer"><span>â—‰</span><kbd>P</kbd></div>
      </div>
    </div>

    <div class="bottom">
      <div class="note">
        <div class="lang-toggle">
          <button id="langFR">FR</button>
          <button id="langKO" class="active">í•œêµ­ì–´</button>
        </div>
        <div class="note-text" id="noteText">
          <span data-lang="fr" id="textFR">L'appartement n'est pas un lieu. C'est un Ã©tat.<br/>Ici, les murs respirent avec vous. La lumiÃ¨re ne vient pas d'ailleurs â€” elle Ã©mane de ce qui est prÃ©sent.<br/>Entrez. Restez. Le temps suspend son vol.</span>
          <span data-lang="ko" class="visible" id="textKO">ì•„íŒŒíŠ¸ëŠ” ì¥ì†Œê°€ ì•„ë‹™ë‹ˆë‹¤. ìƒíƒœì…ë‹ˆë‹¤.<br/>ì—¬ê¸°ì„œ ë²½ì€ ë‹¹ì‹ ê³¼ í•¨ê»˜ ìˆ¨ì‰½ë‹ˆë‹¤. ë¹›ì€ ë‹¤ë¥¸ ê³³ì—ì„œ ì˜¤ì§€ ì•ŠìŠµë‹ˆë‹¤ â€” ì¡´ì¬í•˜ëŠ” ê²ƒì—ì„œ ë°œì‚°ë©ë‹ˆë‹¤.<br/>ë“¤ì–´ì˜¤ì„¸ìš”. ë¨¸ë¬´ë¥´ì„¸ìš”. ì‹œê°„ì´ ë‚ ê°œë¥¼ ì ‘ìŠµë‹ˆë‹¤.</span>
        </div>
        <div class="hint">
          <span data-lang="fr">Glisser pour orbiter Â· Scroll pour zoomer Â· Double-clic pour reset Â· Touches: 1-4 (ambiances), F (plein Ã©cran), Z (zen), P (capture)</span>
          <span data-lang="ko" class="visible">ë“œë˜ê·¸í•˜ì—¬ íšŒì „ Â· ìŠ¤í¬ë¡¤ë¡œ ì¤Œ Â· ë”ë¸”í´ë¦­ìœ¼ë¡œ ë¦¬ì…‹ Â· í‚¤: 1-4 (ë¶„ìœ„ê¸°), F (ì „ì²´í™”ë©´), Z (ì  ), P (ìº¡ì²˜)</span>
        </div>
      </div>
      <div></div>
    </div>
  </div>

  <div id="toast" class="toast">CapturÃ©</div>
  <div class="signature">LifeOS â€” apartmento</div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // ---------- Utilities ----------
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const lerp = (a, b, t) => a + (b - a) * t;
    const smoothstep = (a, b, x) => {
      const t = clamp((x - a) / (b - a), 0, 1);
      return t * t * (3 - 2 * t);
    };

    // ---------- Canvas / Renderer ----------
    const canvas = document.getElementById("c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.setClearColor(0x08090e, 1);

    // Scene / Camera
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x08090e, 4.0, 22.0);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.05, 100);
    // Position initiale : MultiplicitÃ© (vue haute, le monde des possibles)
    camera.position.set(0.1, 4.5, 5.5);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.3;
    controls.zoomSpeed = 0.6;
    controls.minDistance = 3.0;
    controls.maxDistance = 15.0;
    controls.target.set(0, 0.5, 0);
    controls.update();

    // ---------- Mobile parallax ----------
    let orientEnabled = false;
    let orientX = 0, orientY = 0;

    async function enableOrientation(){
      if (orientEnabled) return;
      const hasAPI = (typeof DeviceOrientationEvent !== "undefined");
      if (!hasAPI) return;
      try {
        if (typeof DeviceOrientationEvent.requestPermission === "function"){
          const res = await DeviceOrientationEvent.requestPermission();
          if (res !== "granted") return;
        }
        window.addEventListener("deviceorientation", (e) => {
          const g = (e.gamma || 0);
          const b = (e.beta || 0);
          orientX = clamp(g / 45, -1, 1);
          orientY = clamp(b / 45, -1, 1);
        }, { passive:true });
        orientEnabled = true;
        toast("Parallax activÃ©");
      } catch (err){}
    }

    window.addEventListener("touchend", () => { enableOrientation(); }, { once:true, passive:true });

    // ---------- Mode configurations ----------
    let mode = -1; // DÃ©marre en mode Signature

    const MODES = {
      '-1': { // Signature â€” Bleu d'accueil
        name: "EntrÃ©e",
        nameKO: "ì…ì¥",
        bgColor: 0x08090f,
        fogColor: 0x08090f,
        hemiSky: 0xb1a5e6,      // Twinkle/halo
        hemiGround: 0x0a0812,
        hemiIntensity: 0.55,
        dirColor: 0x696293,      // Base signature
        dirIntensity: 0.45,
        particleHue1: 0.72,      // Bleu-violet
        particleHue2: 0.78,
        textFR: "Bienvenue.<br/>L'espace vous attend.",
        textKO: "í™˜ì˜í•©ë‹ˆë‹¤.<br/>ê³µê°„ì´ ë‹¹ì‹ ì„ ê¸°ë‹¤ë¦½ë‹ˆë‹¤."
      },
      0: { // Aube
        name: "Aube",
        nameKO: "ìƒˆë²½",
        bgColor: 0x0a0b12,
        fogColor: 0x0a0b12,
        hemiSky: 0xffeedd,
        hemiGround: 0x0a0812,
        hemiIntensity: 0.4,
        dirColor: 0xffd4a8,
        dirIntensity: 0.35,
        particleHue1: 0.08,
        particleHue2: 0.12,
        textFR: "L'aube ne commence pas par le soleil.<br/>Elle commence par le silence qui l'attend.",
        textKO: "ìƒˆë²½ì€ íƒœì–‘ìœ¼ë¡œ ì‹œì‘ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.<br/>ê·¸ê²ƒì„ ê¸°ë‹¤ë¦¬ëŠ” ì¹¨ë¬µìœ¼ë¡œ ì‹œì‘ë©ë‹ˆë‹¤."
      },
      1: { // Jour
        name: "Jour",
        nameKO: "ë‚®",
        bgColor: 0x0c0e16,
        fogColor: 0x0c0e16,
        hemiSky: 0xc8e0ff,
        hemiGround: 0x0b1020,
        hemiIntensity: 0.6,
        dirColor: 0xffffff,
        dirIntensity: 0.5,
        particleHue1: 0.55,
        particleHue2: 0.62,
        textFR: "La pleine lumiÃ¨re n'Ã©blouit pas.<br/>Elle rÃ©vÃ¨le ce qui Ã©tait toujours lÃ , attendant d'Ãªtre vu.",
        textKO: "ì¶©ë§Œí•œ ë¹›ì€ ëˆˆë¶€ì‹œê²Œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.<br/>í•­ìƒ ê±°ê¸° ìˆì—ˆë˜ ê²ƒì„, ë³´ì—¬ì§€ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ë˜ ê²ƒì„ ë“œëŸ¬ëƒ…ë‹ˆë‹¤."
      },
      2: { // CrÃ©puscule
        name: "CrÃ©puscule",
        nameKO: "í™©í˜¼",
        bgColor: 0x0e0910,
        fogColor: 0x0e0910,
        hemiSky: 0xffb088,
        hemiGround: 0x100814,
        hemiIntensity: 0.45,
        dirColor: 0xff9966,
        dirIntensity: 0.4,
        particleHue1: 0.02,
        particleHue2: 0.08,
        textFR: "Le crÃ©puscule est l'heure oÃ¹ le monde consent enfin<br/>Ã  montrer ses ombres.",
        textKO: "í™©í˜¼ì€ ì„¸ìƒì´ ë§ˆì¹¨ë‚´ ê·¸ ê·¸ë¦¼ìë¥¼<br/>ë“œëŸ¬ë‚´ê¸°ë¡œ ë™ì˜í•˜ëŠ” ì‹œê°„ì…ë‹ˆë‹¤."
      },
      3: { // Nuit
        name: "Nuit",
        nameKO: "ë°¤",
        bgColor: 0x050608,
        fogColor: 0x050608,
        hemiSky: 0x8090b0,
        hemiGround: 0x020308,
        hemiIntensity: 0.25,
        dirColor: 0x6080c0,
        dirIntensity: 0.2,
        particleHue1: 0.65,
        particleHue2: 0.72,
        textFR: "La nuit n'est pas l'absence de lumiÃ¨re.<br/>C'est l'espace oÃ¹ la lumiÃ¨re intÃ©rieure devient visible.",
        textKO: "ë°¤ì€ ë¹›ì˜ ë¶€ì¬ê°€ ì•„ë‹™ë‹ˆë‹¤.<br/>ë‚´ë©´ì˜ ë¹›ì´ ë³´ì´ê²Œ ë˜ëŠ” ê³µê°„ì…ë‹ˆë‹¤."
      }
    };

    // ---------- Language System ----------
    let currentLang = "ko";
    const langFRBtn = document.getElementById("langFR");
    const langKOBtn = document.getElementById("langKO");
    const textFR = document.getElementById("textFR");
    const textKO = document.getElementById("textKO");

    function setLang(lang) {
      currentLang = lang;
      document.querySelectorAll("[data-lang]").forEach(el => {
        el.classList.toggle("visible", el.getAttribute("data-lang") === lang);
      });
      langFRBtn.classList.toggle("active", lang === "fr");
      langKOBtn.classList.toggle("active", lang === "ko");
      updateModeText();
    }

    function updateModeText() {
      const cfg = MODES[mode];
      if (currentLang === "fr") {
        textFR.innerHTML = cfg.textFR;
      } else {
        textKO.innerHTML = cfg.textKO;
      }
    }

    langFRBtn.addEventListener("click", () => setLang("fr"));
    langKOBtn.addEventListener("click", () => setLang("ko"));

    // ---------- Lighting ----------
    const hemi = new THREE.HemisphereLight(0xffeedd, 0x0a0812, 0.4);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffd4a8, 0.35);
    dir.position.set(4.0, 5.0, 3.0);
    scene.add(dir);

    // Ambient glow
    const ambient = new THREE.AmbientLight(0x101420, 0.15);
    scene.add(ambient);

    // ---------- Room geometry (abstract apartment) ----------
    // Floor
    const floorGeo = new THREE.PlaneGeometry(16, 16);
    const floorMat = new THREE.MeshStandardMaterial({ 
      color: 0x0a0c14, 
      roughness: 0.92, 
      metalness: 0.02 
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    scene.add(floor);

    // Abstract walls (thin vertical planes suggesting space)
    const wallGroup = new THREE.Group();
    scene.add(wallGroup);

    const WALL_COUNT = 7;
    const wallGeo = new THREE.BoxGeometry(0.03, 2.8, 4.2);
    const walls = [];

    for (let i = 0; i < WALL_COUNT; i++) {
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0x12151f,
        roughness: 0.4,
        metalness: 0.08,
        transmission: 0.35,
        thickness: 0.8,
        ior: 1.2,
        transparent: true,
        opacity: 0.18,
        clearcoat: 0.25,
        clearcoatRoughness: 0.3,
      });
      const m = new THREE.Mesh(wallGeo, mat);
      const x = lerp(-2.8, 2.8, i / (WALL_COUNT - 1));
      m.position.set(x, 1.4, 0);
      m.rotation.y = Math.sin(i * 0.9) * 0.12;
      walls.push(m);
      wallGroup.add(m);
    }

    // Ceiling hint (very subtle)
    const ceilingGeo = new THREE.PlaneGeometry(12, 12);
    const ceilingMat = new THREE.MeshBasicMaterial({ 
      color: 0x0a0c12, 
      transparent: true, 
      opacity: 0.3 
    });
    const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = 3.2;
    scene.add(ceiling);

    // ---------- Particule de prÃ©sence (unique) ----------
    const presenceMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.0,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const presenceGeometry = new THREE.SphereGeometry(0.06, 16, 16);
    const presenceParticle = new THREE.Mesh(presenceGeometry, presenceMaterial);
    presenceParticle.visible = false;
    scene.add(presenceParticle);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â•â•  BULLES 3D â€” Billes de verre (prÃ©sences, pas dÃ©cor)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const bubbleGroup = new THREE.Group();
    scene.add(bubbleGroup);
    
    const MAX_BUBBLES = 12;
    const bubbles = [];
    
    // MatÃ©riau verre â€” dÃ©poli, subtil, le bleu vient de la lumiÃ¨re
    const bubbleMaterial = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      roughness: 0.15,
      metalness: 0.0,
      transmission: 0.92,
      thickness: 1.2,
      ior: 1.45,
      transparent: true,
      opacity: 0.6,
      clearcoat: 0.3,
      clearcoatRoughness: 0.1,
      envMapIntensity: 0.5,
    });
    
    // CrÃ©er les bulles (toutes, mais invisibles au dÃ©part)
    for (let i = 0; i < MAX_BUBBLES; i++) {
      const radius = 0.15 + Math.random() * 0.35; // Tailles variÃ©es
      const geo = new THREE.SphereGeometry(radius, 32, 32);
      const bubble = new THREE.Mesh(geo, bubbleMaterial.clone());
      
      // Position initiale alÃ©atoire dans l'espace
      bubble.position.set(
        (Math.random() - 0.5) * 5,
        0.5 + Math.random() * 2.2,
        (Math.random() - 0.5) * 5
      );
      
      // DonnÃ©es pour l'animation
      bubble.userData = {
        baseY: bubble.position.y,
        phase: Math.random() * Math.PI * 2,
        speed: 0.1 + Math.random() * 0.15,
        driftX: (Math.random() - 0.5) * 0.02,
        driftZ: (Math.random() - 0.5) * 0.02,
      };
      
      bubble.visible = false; // Invisible par dÃ©faut
      bubbles.push(bubble);
      bubbleGroup.add(bubble);
    }
    
    // Configuration des bulles par mode
    const BUBBLE_CONFIG = {
      '-1': { count: 2, opacity: 0.4 },   // Signature: quelques-unes, discrÃ¨tes
      0: { count: 0, opacity: 0 },         // Aube: aucune (seuil)
      1: { count: 0, opacity: 0 },         // Jour: aucune (clartÃ©)
      2: { count: 3, opacity: 0.5 },       // CrÃ©puscule: apparition timide
      3: { count: 8, opacity: 0.65 },      // Nuit: prÃ©sence claire
    };
    
    let currentBubbleCount = 0;
    let targetBubbleOpacity = 0;
    let zenBubblesActive = false;
    
    function updateBubblesForMode(modeIndex) {
      const cfg = BUBBLE_CONFIG[modeIndex] || { count: 0, opacity: 0 };
      currentBubbleCount = cfg.count;
      targetBubbleOpacity = cfg.opacity;
      
      // Si Zen actif, plus de bulles
      if (zenBubblesActive) {
        currentBubbleCount = Math.min(MAX_BUBBLES, 10);
        targetBubbleOpacity = 0.7;
      }
      
      // Activer/dÃ©sactiver les bulles
      bubbles.forEach((b, i) => {
        const shouldShow = i < currentBubbleCount;
        if (shouldShow && !b.visible) {
          // Repositionner alÃ©atoirement Ã  l'apparition
          b.position.set(
            (Math.random() - 0.5) * 5,
            0.5 + Math.random() * 2.2,
            (Math.random() - 0.5) * 5
          );
          b.userData.baseY = b.position.y;
        }
        b.visible = shouldShow;
      });
    }
    
    function animateBubbles(time) {
      bubbles.forEach((bubble, i) => {
        if (!bubble.visible) return;
        
        const d = bubble.userData;
        
        // Mouvement trÃ¨s lent â€” quasi immobile
        bubble.position.y = d.baseY + Math.sin(time * d.speed + d.phase) * 0.08;
        bubble.position.x += d.driftX * 0.01;
        bubble.position.z += d.driftZ * 0.01;
        
        // Contraindre dans l'espace
        if (Math.abs(bubble.position.x) > 3) d.driftX *= -1;
        if (Math.abs(bubble.position.z) > 3) d.driftZ *= -1;
        
        // Transition d'opacitÃ© douce
        const mat = bubble.material;
        mat.opacity = lerp(mat.opacity, targetBubbleOpacity, 0.02);
      });
    }

    // ---------- Light particles (inhabiting the space) ----------
    const POINTS = 12000;
    const positions = new Float32Array(POINTS * 3);
    const seeds = new Float32Array(POINTS * 3);

    for (let i = 0; i < POINTS; i++) {
      const ix = i * 3;
      // Distribute in room-like volume
      const x = (Math.random() - 0.5) * 6.0;
      const y = 0.1 + Math.pow(Math.random(), 0.8) * 2.8;
      const z = (Math.random() - 0.5) * 6.0;
      
      positions[ix + 0] = x;
      positions[ix + 1] = y;
      positions[ix + 2] = z;

      seeds[ix + 0] = Math.random() * 10.0;
      seeds[ix + 1] = Math.random() * 10.0;
      seeds[ix + 2] = Math.random() * 10.0;
    }

    const geom = new THREE.BufferGeometry();
    geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geom.setAttribute("seed", new THREE.BufferAttribute(seeds, 3));

    const uniforms = {
      uTime: { value: 0 },
      uMode: { value: 0 },
      uHue1: { value: 0.08 },
      uHue2: { value: 0.12 },
      uBreath: { value: 0 },
      uOpacity: { value: 1.0 },
      uTransition: { value: 0 },
      uVoie: { value: 0.0 }, // 0 = MultiplicitÃ© (tous visibles), 1 = Voie (seule la ligne)
      // Zones de seuils autour de certains volumes (Ã©tats intÃ©rieurs)
      uSeuilCenters: { value: [
        new THREE.Vector3(-1.4, 1.0, -0.7),  // densitÃ© + lÃ©ger ralentissement
        new THREE.Vector3(0.0,  1.0,  0.3),  // surtout ralentissement (temps Ã©paissi)
        new THREE.Vector3(1.6,  1.1,  0.8),  // lÃ©gÃ¨re dÃ©rive chromatique
      ]},
      uSeuilRadius:  { value: [1.2, 1.0, 1.0] },
      uSeuilDensity: { value: [0.35, 0.0, 0.25] },
      uSeuilSlow:    { value: [0.25, 0.45, 0.0] },
      uSeuilHueShift:{ value: [0.012, 0.0, -0.015] },
    };

    const vert = /* glsl */`
      uniform float uTime;
      uniform float uMode;
      uniform float uBreath;
      uniform float uVoie;
      uniform vec3  uSeuilCenters[3];
      uniform float uSeuilRadius[3];
      uniform float uSeuilDensity[3];
      uniform float uSeuilSlow[3];
      uniform float uSeuilHueShift[3];
      attribute vec3 seed;

      varying float vGlow;
      varying float vHeight;
      varying float vDepth;
      varying float vVoieAlpha;
      varying float vDensityBoost;
      varying float vHueShift;

      void main() {
        vec3 p = position;

        // Champs de seuil subtils autour de certains volumes
        vDensityBoost = 0.0;
        vHueShift = 0.0;
        float slowAccum = 0.0;
        for (int i = 0; i < 3; i++) {
          vec3 c = uSeuilCenters[i];
          float r = uSeuilRadius[i];
          float d = length(p - c);
          float k = 1.0 - smoothstep(r, r * 0.4, d); // 0 dehors, 1 au coeur
          vDensityBoost += uSeuilDensity[i] * k;
          vHueShift += uSeuilHueShift[i] * k;
          slowAccum += uSeuilSlow[i] * k;
        }
        float motionFactor = 1.0 - clamp(slowAccum, 0.0, 0.6);

        float t = uTime * motionFactor;
        
        // Organic breathing movement (ralentie dans les seuils)
        float breath = uBreath * 0.06 * motionFactor;
        float n1 = sin(seed.x * 2.0 + t * 0.4) * cos(seed.y * 1.5 + t * 0.3);
        float n2 = cos(seed.z * 1.8 + t * 0.35);
        
        p.x += n1 * breath;
        p.y += sin(seed.y * 3.0 + t * 0.5) * breath * 0.7;
        p.z += n2 * breath;

        // Slow drift upward (like dust in light)
        float drift = mod(seed.x + t * 0.02, 1.0);
        p.y += drift * 0.15;

        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        // Point size with perspective and micro-variation (organique)
        float jitter = fract(seed.y * 0.37);
        float baseSize = 1.0 + 0.15 * (jitter - 0.5); // Â±15% de variance
        float size = (1.8 + 1.2 * (0.5 + 0.5 * sin(seed.x * 4.0 + t * 0.8))) * baseSize;
        size *= (280.0 / -mvPosition.z);
        gl_PointSize = clamp(size, 0.8, 6.0);

        vDepth = clamp((-mvPosition.z - 2.5) / 12.0, 0.0, 1.0);
        vHeight = clamp(p.y / 3.0, 0.0, 1.0);
        vGlow = 0.3 + 0.7 * (0.5 + 0.5 * sin(seed.z * 5.0 + t * 0.9));
        
        // Voie : attÃ©nuation des points hauts
        // En MultiplicitÃ© (uVoie=0): tous visibles
        // En Voie (uVoie=1): seuls les points bas restent (la ligne)
        float heightFade = 1.0 - smoothstep(0.0, 0.4, p.y) * uVoie;
        vVoieAlpha = heightFade;
      }
    `;

    const frag = /* glsl */`
      precision highp float;

      uniform float uHue1;
      uniform float uHue2;
      uniform float uOpacity;
      uniform float uTransition;
      uniform float uVoie;

      varying float vGlow;
      varying float vHeight;
      varying float vDepth;
      varying float vVoieAlpha;
      varying float vDensityBoost;
      varying float vHueShift;

      vec3 hsl2rgb(float h, float s, float l) {
        float c = (1.0 - abs(2.0 * l - 1.0)) * s;
        float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
        float m = l - c * 0.5;
        vec3 rgb;
        if (h < 0.166667) rgb = vec3(c, x, 0.0);
        else if (h < 0.333333) rgb = vec3(x, c, 0.0);
        else if (h < 0.5) rgb = vec3(0.0, c, x);
        else if (h < 0.666667) rgb = vec3(0.0, x, c);
        else if (h < 0.833333) rgb = vec3(x, 0.0, c);
        else rgb = vec3(c, 0.0, x);
        return rgb + m;
      }

      void main(){
        vec2 uv = gl_PointCoord.xy * 2.0 - 1.0;
        float r2 = dot(uv, uv);
        float falloff = exp(-3.5 * r2);
        float core = exp(-12.0 * r2);

        // Interpolate hue based on height + trÃ¨s lÃ©ger glissement de seuil
        float h = mix(uHue1, uHue2, vHeight) + vHueShift;
        h = clamp(h, 0.0, 1.0);
        float s = 0.45 + 0.25 * vGlow;
        float l = 0.55 + 0.25 * vGlow;
        
        vec3 col = hsl2rgb(h, s, l);
        
        // Depth fade
        col *= (0.7 + 0.3 * (1.0 - vDepth));
        
        // Glow modulation
        col *= (0.8 + 0.4 * vGlow);

        float alpha = (0.15 + 0.5 * falloff + 0.35 * core) * uOpacity;
        // LÃ©gÃ¨re augmentation locale de "densitÃ©" lumineuse dans les seuils
        alpha *= (1.0 + clamp(vDensityBoost, 0.0, 0.5));
        
        // En Voie: seule la ligne basse reste visible
        alpha *= vVoieAlpha;
        
        // Si quasi invisible, discard
        if (alpha < 0.01) discard;

        gl_FragColor = vec4(col, alpha);

        if (r2 > 1.0) discard;
      }
    `;

    const mat = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: vert,
      fragmentShader: frag,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(geom, mat);
    scene.add(points);

    // ---------- Mode System ----------
    let targetMode = -1;

    const btnSignature = document.getElementById("btnSignature");
    const btnA = document.getElementById("btnA");
    const btnB = document.getElementById("btnB");
    const btnC = document.getElementById("btnC");
    const btnD = document.getElementById("btnD");
    const btnFullscreen = document.getElementById("btnFullscreen");
    const btnZen = document.getElementById("btnZen");
    const btnCapture = document.getElementById("btnCapture");
    
    const pillbar = document.querySelector(".pillbar");
    const note = document.querySelector(".note");
    const brand = document.querySelector(".brand");

    function setActivePill(which){
      btnSignature.classList.toggle("active", which === -1);
      [btnA, btnB, btnC, btnD].forEach((b, i) => {
        b.classList.toggle("active", i === which);
      });
    }

    function applyMode(next, instant = false){
      targetMode = next;
      if (instant) mode = next;
      
      const cfg = MODES[next];
      setActivePill(next);
      
      // Update text based on current language
      updateModeText();
      
      // Animate colors
      const duration = instant ? 0 : 1200;
      const start = performance.now();
      const startBg = renderer.getClearColor(new THREE.Color());
      const endBg = new THREE.Color(cfg.bgColor);
      const startFog = scene.fog.color.clone();
      const endFog = new THREE.Color(cfg.fogColor);
      const startHemiSky = hemi.color.clone();
      const endHemiSky = new THREE.Color(cfg.hemiSky);
      const startHemiGround = hemi.groundColor.clone();
      const endHemiGround = new THREE.Color(cfg.hemiGround);
      const startDir = dir.color.clone();
      const endDir = new THREE.Color(cfg.dirColor);
      const startHue1 = uniforms.uHue1.value;
      const startHue2 = uniforms.uHue2.value;
      
      function animateMode(){
        const elapsed = performance.now() - start;
        const t = instant ? 1 : smoothstep(0, duration, elapsed);
        
        renderer.setClearColor(startBg.clone().lerp(endBg, t));
        scene.fog.color.copy(startFog).lerp(endFog, t);
        hemi.color.copy(startHemiSky).lerp(endHemiSky, t);
        hemi.groundColor.copy(startHemiGround).lerp(endHemiGround, t);
        hemi.intensity = lerp(hemi.intensity, cfg.hemiIntensity, t * 0.1);
        dir.color.copy(startDir).lerp(endDir, t);
        dir.intensity = lerp(dir.intensity, cfg.dirIntensity, t * 0.1);
        
        uniforms.uHue1.value = lerp(startHue1, cfg.particleHue1, t);
        uniforms.uHue2.value = lerp(startHue2, cfg.particleHue2, t);
        
        // Update wall materials
        for (const wall of walls) {
          const m = wall.material;
          m.opacity = lerp(m.opacity, 0.15 + (next === 3 ? 0.08 : 0.05), t * 0.05);
        }
        
        if (t < 1) requestAnimationFrame(animateMode);
        else mode = next;
      }
      animateMode();
      
      // Synchroniser le son avec le mode
      updateSoundForMode(next);
      
      // Synchroniser les bulles avec le mode
      updateBubblesForMode(next);
      
      // Influence du mode sur le regard
      // Nuit suggÃ¨re doucement la Voie (sans forcer)
      // Ce n'est qu'une invitation, pas une contrainte
      if (next === 3 && regard === "multiplicite") {
        // Suggestion lÃ©gÃ¨re: on ne bascule pas, mais on attenue un peu
        // La voie commence Ã  se dessiner dans la nuit
        // (L'utilisateur doit choisir activement d'y aller)
      }
    }

    btnSignature.addEventListener("click", () => applyMode(-1));
    btnA.addEventListener("click", () => applyMode(0));
    btnB.addEventListener("click", () => applyMode(1));
    btnC.addEventListener("click", () => applyMode(2));
    btnD.addEventListener("click", () => applyMode(3));

    // ---------- Toast ----------
    const toastEl = document.getElementById("toast");
    let toastTimer = null;
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => toastEl.classList.remove("show"), 1400);
    }

    // ---------- Capture ----------
    function capture(){
      renderer.render(scene, camera);
      const url = canvas.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = url;
      const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
      const modeName = MODES[mode].name.toLowerCase();
      a.download = `apartmento_${modeName}_${stamp}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      toast("CapturÃ©");
    }
    btnCapture.addEventListener("click", capture);

    // ---------- Fullscreen / Zen ----------
    async function enterFullscreen(){
      try {
        if (!document.fullscreenElement){
          await document.documentElement.requestFullscreen({ navigationUI: "hide" });
          toast("Plein Ã©cran");
        } else {
          await document.exitFullscreen();
          toast("FenÃªtrÃ©");
        }
      } catch (err){
        toast("Plein Ã©cran non disponible");
      }
    }
    function toggleZen(){
      document.body.classList.toggle("zen");
      const isZen = document.body.classList.contains("zen");
      toast(isZen ? "Mode Zen" : "Interface visible");
      
      // En Zen: bulles pleines, lentes, presque sacrÃ©es
      zenBubblesActive = isZen;
      updateBubblesForMode(mode);
      
      // En Zen, passer en Voie (le chemin se rÃ©vÃ¨le)
      if (isZen && regard === "multiplicite") {
        setRegard("voie");
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â•â•  REGARD : MultiplicitÃ© â†” Voie
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // D'en haut, il y a mille chemins.
    // Ã€ hauteur d'homme, il n'y en a qu'un.
    //
    // Ce n'est PAS une rotation de camÃ©ra.
    // C'est le mÃªme espace qui change de sens selon le point de vue existentiel.
    //
    // MultiplicitÃ© : le possible, le vertige, l'indÃ©cision
    // Voie : le vÃ©cu, le choix, la responsabilitÃ©
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let regard = "multiplicite"; // "multiplicite" | "voie"
    const btnPosture = document.getElementById("btnPosture");
    const postureIcon = document.getElementById("postureIcon");
    
    // Configuration du regard
    const REGARD_CONFIG = {
      multiplicite: {
        // Vue haute/oblique : myriade de points, densitÃ©, possibles
        cameraPos: { x: 0.1, y: 4.5, z: 5.5 },
        targetPos: { x: 0, y: 0.5, z: 0 },
        voie: 0.0,  // Tous les points visibles
        icon: "â—‡",  // Diamant = multiplicitÃ©, richesse
        label: { fr: "MultiplicitÃ©", kr: "ë‹¤ì–‘ì„±" }
      },
      voie: {
        // Vue rasante : la ligne, le chemin, la trace
        cameraPos: { x: 0, y: 0.15, z: 9.5 },
        targetPos: { x: 0, y: 0.1, z: -5 },
        voie: 1.0,  // Seule la ligne basse visible
        icon: "â”€",  // Ligne horizontale = voie unique
        label: { fr: "Voie", kr: "ê¸¸" }
      }
    };
    
    let targetVoie = 0.0;
    
    function setRegard(newRegard, instant = false) {
      regard = newRegard;
      const cfg = REGARD_CONFIG[regard];
      postureIcon.textContent = cfg.icon;
      btnPosture.classList.toggle("active", regard === "voie");
      targetVoie = cfg.voie;
      
      if (instant) {
        camera.position.set(cfg.cameraPos.x, cfg.cameraPos.y, cfg.cameraPos.z);
        controls.target.set(cfg.targetPos.x, cfg.targetPos.y, cfg.targetPos.z);
        uniforms.uVoie.value = cfg.voie;
        controls.update();
      } else {
        // Transition lente, presque imperceptible
        // La bascule existentielle ne se fait pas brusquement
        const duration = 3500; // 3.5 secondes
        const start = performance.now();
        const startPos = camera.position.clone();
        const startTarget = controls.target.clone();
        const startVoie = uniforms.uVoie.value;
        const endPos = new THREE.Vector3(cfg.cameraPos.x, cfg.cameraPos.y, cfg.cameraPos.z);
        const endTarget = new THREE.Vector3(cfg.targetPos.x, cfg.targetPos.y, cfg.targetPos.z);
        
        function animateRegard() {
          const elapsed = performance.now() - start;
          const t = smoothstep(0, duration, elapsed);
          
          camera.position.lerpVectors(startPos, endPos, t);
          controls.target.lerpVectors(startTarget, endTarget, t);
          
          // Transition de l'attÃ©nuation verticale
          uniforms.uVoie.value = lerp(startVoie, cfg.voie, t);
          
          controls.update();
          
          if (t < 1) requestAnimationFrame(animateRegard);
        }
        animateRegard();
      }
    }
    
    function toggleRegard() {
      const newRegard = regard === "multiplicite" ? "voie" : "multiplicite";
      setRegard(newRegard);
      const label = REGARD_CONFIG[newRegard].label;
      toast(currentLang === "fr" ? label.fr : label.kr);
    }
    
    btnPosture.addEventListener("click", toggleRegard);
    btnFullscreen.addEventListener("click", () => { enableOrientation(); enterFullscreen(); });
    btnZen.addEventListener("click", toggleZen);

    document.addEventListener("fullscreenchange", () => {
      const on = !!document.fullscreenElement;
      if (on) document.body.classList.add("zen");
      else document.body.classList.remove("zen");
    });

    // ---------- Idle cursor behavior ----------
    let idleTimer = null;
    function markActive(){
      document.body.classList.remove("cursor-hide");
      clearTimeout(idleTimer);
      idleTimer = setTimeout(() => {
        document.body.classList.add("cursor-hide");
      }, 2200);
    }
    window.addEventListener("mousemove", markActive, { passive:true });
    window.addEventListener("mousedown", markActive, { passive:true });
    window.addEventListener("touchstart", markActive, { passive:true });
    markActive();

    // ---------- Keyboard shortcuts ----------
    window.addEventListener("keydown", (e) => {
      if (e.key === "0") applyMode(-1);
      if (e.key === "1") applyMode(0);
      if (e.key === "2") applyMode(1);
      if (e.key === "3") applyMode(2);
      if (e.key === "4") applyMode(3);
      if (e.key.toLowerCase() === "s") toggleSound();
      if (e.key.toLowerCase() === "v" || e.key.toLowerCase() === "m") toggleRegard();
      if (e.key.toLowerCase() === "f") enterFullscreen();
      if (e.key.toLowerCase() === "z") toggleZen();
      if (e.key.toLowerCase() === "p") capture();
    });

    canvas.addEventListener("dblclick", () => {
      // Double-clic : revenir Ã  la MultiplicitÃ©
      setRegard("multiplicite");
      toast(currentLang === "fr" ? "MultiplicitÃ©" : "ë‹¤ì–‘ì„±");
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â•â•  SYSTÃˆME SONORE GÃ‰NÃ‰RATIF â€” 3 COUCHES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let audioCtx = null;
    let soundEnabled = false;
    let masterGain = null;
    
    // Couche 1: Drone (respiration sonore)
    let droneOsc1 = null;
    let droneOsc2 = null;
    let droneGain = null;
    let droneFilter = null;
    
    // Couche 2: Notes Ã©parses (poÃ©sie)
    let noteGain = null;
    let lastNoteTime = 0;
    let noteInterval = 12000; // 8-15 secondes
    
    // Couche 3: Modulation vivante
    let lfoOsc = null;
    let lfoGain = null;
    
    const btnSound = document.getElementById("btnSound");
    const soundIcon = document.getElementById("soundIcon");
    
    // Configuration sonore par mode
    const SOUND_CONFIG = {
      '-1': { // Signature
        droneFreq: 92,
        droneDetune: 4,
        filterFreq: 450,
        droneVol: 0.07,
        noteProb: 0.15,
        noteFreqs: [494, 587, 740], // B4, D5, F#5 â€” bleuÃ¢tre
        lfoSpeed: 0.07,
        warmth: 0.25
      },
      0: { // Aube
        droneFreq: 82,      // trÃ¨s bas, presque absent
        droneDetune: 3,
        filterFreq: 400,
        droneVol: 0.06,
        noteProb: 0.4,      // notes frÃ©quentes
        noteFreqs: [523, 659, 784, 880], // C5, E5, G5, A5 â€” clair
        lfoSpeed: 0.08,
        warmth: 0.2
      },
      1: { // Jour
        droneFreq: 110,
        droneDetune: 5,
        filterFreq: 600,
        droneVol: 0.08,
        noteProb: 0.25,     // parcimonieux
        noteFreqs: [392, 494, 587, 698], // G4, B4, D5, F5
        lfoSpeed: 0.1,
        warmth: 0.3
      },
      2: { // CrÃ©puscule
        droneFreq: 73,      // plus chaud
        droneDetune: 8,
        filterFreq: 350,
        droneVol: 0.1,
        noteProb: 0.08,     // trÃ¨s rare
        noteFreqs: [349, 440, 523], // F4, A4, C5 â€” dorÃ©
        lfoSpeed: 0.06,
        warmth: 0.5
      },
      3: { // Nuit
        droneFreq: 55,      // grave, enveloppant
        droneDetune: 12,
        filterFreq: 250,
        droneVol: 0.12,
        noteProb: 0,        // pas de notes
        noteFreqs: [],
        lfoSpeed: 0.03,
        warmth: 0.7
      }
    };
    
    function initAudio() {
      if (audioCtx) return;
      
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      
      // Master gain avec fade-in
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0;
      masterGain.connect(audioCtx.destination);
      
      // â”€â”€â”€ Couche 1: Drone â”€â”€â”€
      droneGain = audioCtx.createGain();
      droneGain.gain.value = 0.08;
      
      droneFilter = audioCtx.createBiquadFilter();
      droneFilter.type = "lowpass";
      droneFilter.frequency.value = 400;
      droneFilter.Q.value = 1;
      
      // Oscillateur 1 (fondamentale)
      droneOsc1 = audioCtx.createOscillator();
      droneOsc1.type = "sine";
      droneOsc1.frequency.value = 82;
      
      // Oscillateur 2 (harmonique dÃ©saccordÃ©e pour chaleur)
      droneOsc2 = audioCtx.createOscillator();
      droneOsc2.type = "sine";
      droneOsc2.frequency.value = 82 * 1.002; // lÃ©gÃ¨rement dÃ©saccordÃ©
      
      droneOsc1.connect(droneFilter);
      droneOsc2.connect(droneFilter);
      droneFilter.connect(droneGain);
      droneGain.connect(masterGain);
      
      droneOsc1.start();
      droneOsc2.start();
      
      // â”€â”€â”€ Couche 2: Notes â”€â”€â”€
      noteGain = audioCtx.createGain();
      noteGain.gain.value = 0;
      noteGain.connect(masterGain);
      
      // â”€â”€â”€ Couche 3: LFO pour modulation vivante â”€â”€â”€
      lfoOsc = audioCtx.createOscillator();
      lfoOsc.type = "sine";
      lfoOsc.frequency.value = 0.08; // trÃ¨s lent
      
      lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 5; // amplitude de modulation du filtre
      
      lfoOsc.connect(lfoGain);
      lfoGain.connect(droneFilter.frequency);
      lfoOsc.start();
    }
    
    function toggleSound() {
      if (!audioCtx) initAudio();
      
      soundEnabled = !soundEnabled;
      soundIcon.textContent = soundEnabled ? "ğŸ”Š" : "ğŸ”‡";
      btnSound.classList.toggle("active", soundEnabled);
      
      const now = audioCtx.currentTime;
      
      if (soundEnabled) {
        if (audioCtx.state === "suspended") audioCtx.resume();
        // Fade-in doux (5 secondes)
        masterGain.gain.cancelScheduledValues(now);
        masterGain.gain.setValueAtTime(masterGain.gain.value, now);
        masterGain.gain.linearRampToValueAtTime(1.0, now + 5);
      } else {
        // Fade-out (3 secondes)
        masterGain.gain.cancelScheduledValues(now);
        masterGain.gain.setValueAtTime(masterGain.gain.value, now);
        masterGain.gain.linearRampToValueAtTime(0, now + 3);
      }
    }
    
    function updateSoundForMode(modeIndex) {
      if (!audioCtx || !soundEnabled) return;
      
      const cfg = SOUND_CONFIG[modeIndex];
      const now = audioCtx.currentTime;
      const crossfade = 3; // 3 secondes de transition
      
      // Couche 1: Drone
      droneOsc1.frequency.cancelScheduledValues(now);
      droneOsc1.frequency.setValueAtTime(droneOsc1.frequency.value, now);
      droneOsc1.frequency.linearRampToValueAtTime(cfg.droneFreq, now + crossfade);
      
      droneOsc2.frequency.cancelScheduledValues(now);
      droneOsc2.frequency.setValueAtTime(droneOsc2.frequency.value, now);
      droneOsc2.frequency.linearRampToValueAtTime(cfg.droneFreq * (1 + cfg.droneDetune * 0.001), now + crossfade);
      
      droneFilter.frequency.cancelScheduledValues(now);
      droneFilter.frequency.setValueAtTime(droneFilter.frequency.value, now);
      droneFilter.frequency.linearRampToValueAtTime(cfg.filterFreq, now + crossfade);
      
      droneGain.gain.cancelScheduledValues(now);
      droneGain.gain.setValueAtTime(droneGain.gain.value, now);
      droneGain.gain.linearRampToValueAtTime(cfg.droneVol, now + crossfade);
      
      // Couche 3: LFO
      lfoOsc.frequency.cancelScheduledValues(now);
      lfoOsc.frequency.setValueAtTime(lfoOsc.frequency.value, now);
      lfoOsc.frequency.linearRampToValueAtTime(cfg.lfoSpeed, now + crossfade);
      
      lfoGain.gain.cancelScheduledValues(now);
      lfoGain.gain.setValueAtTime(lfoGain.gain.value, now);
      lfoGain.gain.linearRampToValueAtTime(cfg.filterFreq * 0.15, now + crossfade);
    }
    
    function playNote() {
      if (!audioCtx || !soundEnabled) return;
      
      const cfg = SOUND_CONFIG[mode];
      if (cfg.noteProb === 0 || cfg.noteFreqs.length === 0) return;
      if (Math.random() > cfg.noteProb) return;
      
      const now = audioCtx.currentTime;
      const freq = cfg.noteFreqs[Math.floor(Math.random() * cfg.noteFreqs.length)];
      
      // CrÃ©er une note Ã©phÃ©mÃ¨re
      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.value = freq;
      
      const gain = audioCtx.createGain();
      gain.gain.value = 0;
      
      // Reverb simulÃ©e avec delay
      const delay = audioCtx.createDelay();
      delay.delayTime.value = 0.3;
      const delayGain = audioCtx.createGain();
      delayGain.gain.value = 0.3;
      
      osc.connect(gain);
      gain.connect(masterGain);
      gain.connect(delay);
      delay.connect(delayGain);
      delayGain.connect(masterGain);
      
      // Enveloppe douce (attaque lente, decay longue)
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.04, now + 0.8);  // attaque 800ms
      gain.gain.linearRampToValueAtTime(0.02, now + 2.5);  // sustain
      gain.gain.linearRampToValueAtTime(0, now + 6);       // release 6s
      
      osc.start(now);
      osc.stop(now + 7);
    }
    
    function updateSound(time) {
      if (!audioCtx || !soundEnabled) return;
      
      // Couche 2: Notes Ã©parses
      const now = Date.now();
      if (now - lastNoteTime > noteInterval) {
        playNote();
        lastNoteTime = now;
        // Prochain intervalle: 8-15 secondes
        noteInterval = 8000 + Math.random() * 7000;
      }
      
      // Couche 3: Modulation vivante basÃ©e sur le temps
      if (lfoGain) {
        // Micro-variation de l'amplitude LFO basÃ©e sur la respiration visuelle
        const breathMod = 0.8 + 0.4 * Math.sin(time * 0.6);
        lfoGain.gain.value = SOUND_CONFIG[mode].filterFreq * 0.15 * breathMod;
      }
    }
    
    btnSound.addEventListener("click", toggleSound);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â•â•  RITUEL D'ENTRÃ‰E â€” Le bleu est le lieu
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const blueSource = document.getElementById("blueSource");
    const canvasEl = document.getElementById("c");
    const entryHalo = document.getElementById("entryHalo");
    const entryText = document.getElementById("entryText");

    let entryActive = true;
    let entryAborted = false;

    function endEntrySequence() {
      if (!entryActive) return;
      entryActive = false;
      if (entryHalo) entryHalo.style.opacity = "0";
      if (entryText) entryText.style.opacity = "0";
      presenceParticle.visible = false;
      presenceMaterial.opacity = 0.0;
    }

    function abortEntrySequence() {
      if (!entryActive || entryAborted) return;
      entryAborted = true;
      endEntrySequence();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // ---------- Animation loop ----------
    const clock = new THREE.Clock();
    let t = 0;

    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      t += dt;
      uniforms.uTime.value = t;

      // SÃ©quence d'entrÃ©e perceptive (0 â†’ ~6s)
      if (entryActive && !entryAborted) {
        const e = t; // temps en secondes depuis le chargement

        // 1) Respiration lumineuse centrale (0 â†’ 1.5s)
        if (entryHalo) {
          if (e <= 1.6) {
            const phase = Math.max(0.0, Math.min(1.0, e / 1.5));
            const s = 0.85 + 0.25 * Math.sin(phase * Math.PI); // expansion / contraction
            const o = 0.18 * Math.sin(phase * Math.PI);        // opacitÃ© max ~0.18
            entryHalo.style.transform = `translate(-50%, -50%) scale(${s.toFixed(3)})`;
            entryHalo.style.opacity = o.toFixed(3);
          } else {
            // extinction
            entryHalo.style.opacity = "0";
          }
        }

        // 2) Particule unique de prÃ©sence (1.5s â†’ 4.5s)
        if (e >= 1.5 && e <= 4.8) {
          const t2 = Math.max(0.0, Math.min(1.0, (e - 1.5) / 3.0));
          const wave = Math.sin(t2 * Math.PI);
          presenceParticle.visible = true;
          presenceMaterial.opacity = 0.34 * wave; // plus lumineuse mais douce

          const px = lerp(-1.4, 1.4, t2) + 0.2 * Math.sin(t2 * Math.PI * 2.0);
          const py = 0.5 + 0.4 * wave;
          const pz = -0.8 + 0.6 * Math.sin(t2 * Math.PI * 1.3);
          presenceParticle.position.set(px, py, pz);
        } else if (e > 4.8 && presenceParticle.visible) {
          // Dissolution progressive
          presenceMaterial.opacity = Math.max(0, presenceMaterial.opacity - 0.02);
          if (presenceMaterial.opacity <= 0.01) {
            presenceParticle.visible = false;
          }
        }

        // 3) Texte-lumiÃ¨re Ã©phÃ©mÃ¨re (2.5s â†’ ~5.5s)
        if (entryText) {
          let alpha = 0;
          if (e >= 2.5 && e < 3.5) {
            const tt = (e - 2.5) / 1.0; // fade-in 1s
            alpha = 0.15 * (0.5 - 0.5 * Math.cos(tt * Math.PI));
          } else if (e >= 3.5 && e < 5.0) {
            alpha = 0.15;
          } else if (e >= 5.0 && e < 5.8) {
            const tt = (e - 5.0) / 0.8;
            alpha = 0.15 * (1.0 - Math.max(0.0, Math.min(1.0, tt)));
          } else {
            alpha = 0;
          }
          entryText.style.opacity = alpha.toFixed(3);
        }

        // Fin naturelle de la sÃ©quence
        if (e >= 6.0) {
          endEntrySequence();
        }
      }

      // AprÃ¨s la sÃ©quence d'entrÃ©e : une seule particule consciente, quasi immobile
      if (!entryActive) {
        const tl = t * 0.06; // temps Ã©tirÃ©
        const wave = 0.5 + 0.5 * Math.sin(tl * 0.23 + 1.7);
        const radius = 1.7 + 0.3 * Math.sin(tl * 0.31 + 0.4);
        const angle = tl * 0.11 + Math.sin(tl * 0.07);
        const px = Math.cos(angle) * radius * 0.6;
        const pz = Math.sin(angle * 1.13) * radius * 0.4 - 0.6;
        const py = 0.45 + 0.18 * Math.sin(tl * 0.19 + 0.8);
        presenceParticle.visible = true;
        presenceMaterial.opacity = 0.03 * wave; // prÃ©sence Ã  peine au-dessus du champ
        presenceParticle.position.set(px, py, pz);
      }

      // Respiration globale trÃ¨s lente (luminance / mouvement)
      const breathVisual = 0.5 + 0.5 * Math.sin(t * 0.16);
      uniforms.uBreath.value = breathVisual;
      const breathLuma = 0.5 + 0.5 * Math.sin(t * 0.07);
      ambient.intensity = 0.12 + 0.05 * breathLuma;

      // Mobile parallax
      if (orientEnabled){
        const px = orientX * 0.15;
        const py = orientY * 0.1;
        controls.target.x = lerp(controls.target.x, px, 0.03);
        controls.target.y = lerp(controls.target.y, 0.7 + py, 0.03);
      }

      // Gentle wall animation
      for (let i = 0; i < walls.length; i++){
        const w = walls[i];
        const k = i / (walls.length - 1);
        w.rotation.y = Math.sin(t * 0.15 + k * 3.0) * 0.08;
        w.position.x = lerp(-2.8, 2.8, k) + Math.sin(t * 0.12 + k * 2.5) * 0.04;
      }

      // Camera micro-drift
      const drift = 0.012;
      camera.position.x += Math.sin(t * 0.14) * drift * dt;
      camera.position.y += Math.cos(t * 0.11) * drift * dt;

      // Update son gÃ©nÃ©ratif
      updateSound(t);

      // Animation bulles de verre (quasi-immobile)
      animateBubbles(t);

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ---------- Resize ----------
    function onResize(){
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    }
    window.addEventListener("resize", onResize);
    
    // DÃ©marrer en mode Signature (couleurs prÃ©parÃ©es, mais invisible)
    applyMode(-1, true);
    
    // Phase 1: La nappe bleue apparaÃ®t (0 â†’ 2s)
    // "Ah. C'est ce bleu-lÃ ."
    setTimeout(() => {
      blueSource.classList.add("revealed");
    }, 100);
    
    // Phase 2: Les particules Ã©mergent (2.5s)
    // L'espace devient vivant
    setTimeout(() => {
      canvasEl.classList.add("revealed");
    }, 2500);
    
    // Phase 3: Le titre se rÃ©vÃ¨le (4s)
    setTimeout(() => {
      brand.classList.add("revealed");
    }, 4000);
    
    // Phase 4: Les contrÃ´les apparaissent (6s)
    // "Je peux explorer"
    setTimeout(() => {
      pillbar.classList.add("revealed");
    }, 6000);
    
    // Phase 5: La note (8s)
    setTimeout(() => {
      note.classList.add("revealed");
    }, 8000);

    // Si interaction avant 6s â†’ on saute immÃ©diatement la sÃ©quence d'entrÃ©e
    const earlyEvents = ["pointerdown", "keydown", "wheel", "touchstart"]; 
    earlyEvents.forEach(type => {
      window.addEventListener(type, () => {
        if (t < 6.0) abortEntrySequence();
      }, { passive: true });
    });
  </script>
</body>
</html>
